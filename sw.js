/**
 * FractalMerch Service Worker
 * Caching strategy for performance optimization
 */

const CACHE_NAME = 'fractalmerch-v1.2.0';\nconst STATIC_CACHE = 'fractalmerch-static-v1.2.0';\nconst DYNAMIC_CACHE = 'fractalmerch-dynamic-v1.2.0';\nconst IMAGE_CACHE = 'fractalmerch-images-v1.2.0';\n\n// Cache strategies\nconst CACHE_STRATEGIES = {\n    CACHE_FIRST: 'cache-first',\n    NETWORK_FIRST: 'network-first',\n    STALE_WHILE_REVALIDATE: 'stale-while-revalidate',\n    NETWORK_ONLY: 'network-only',\n    CACHE_ONLY: 'cache-only'\n};\n\n// Static assets to cache immediately\nconst STATIC_ASSETS = [\n    '/',\n    '/assets/css/style.css',\n    '/assets/js/main.js',\n    '/assets/js/enhanced-cart.js',\n    '/assets/js/performance-optimizer.js',\n    '/assets/images/icon.png',\n    '/assets/images/icon.ico',\n    '/particulares.php',\n    '/customize-shirt.php',\n    '/offline.html'\n];\n\n// Routes and their caching strategies\nconst ROUTE_STRATEGIES = [\n    {\n        pattern: /\\.(js|css)$/,\n        strategy: CACHE_STRATEGIES.STALE_WHILE_REVALIDATE,\n        cache: STATIC_CACHE\n    },\n    {\n        pattern: /\\.(png|jpg|jpeg|gif|webp|svg|ico)$/,\n        strategy: CACHE_STRATEGIES.CACHE_FIRST,\n        cache: IMAGE_CACHE,\n        expiration: 30 * 24 * 60 * 60 * 1000 // 30 days\n    },\n    {\n        pattern: /\\.(php|html)$/,\n        strategy: CACHE_STRATEGIES.NETWORK_FIRST,\n        cache: DYNAMIC_CACHE,\n        expiration: 24 * 60 * 60 * 1000 // 24 hours\n    },\n    {\n        pattern: /\\/api\\//,\n        strategy: CACHE_STRATEGIES.NETWORK_FIRST,\n        cache: DYNAMIC_CACHE,\n        expiration: 5 * 60 * 1000 // 5 minutes\n    }\n];\n\n// Install event - cache static assets\nself.addEventListener('install', event => {\n    console.log('Service Worker installing...');\n    \n    event.waitUntil(\n        caches.open(STATIC_CACHE)\n            .then(cache => {\n                console.log('Caching static assets...');\n                return cache.addAll(STATIC_ASSETS);\n            })\n            .then(() => {\n                console.log('Static assets cached successfully');\n                return self.skipWaiting();\n            })\n            .catch(error => {\n                console.error('Failed to cache static assets:', error);\n            })\n    );\n});\n\n// Activate event - cleanup old caches\nself.addEventListener('activate', event => {\n    console.log('Service Worker activating...');\n    \n    event.waitUntil(\n        caches.keys()\n            .then(cacheNames => {\n                const deletePromises = cacheNames\n                    .filter(cacheName => {\n                        return cacheName !== STATIC_CACHE && \n                               cacheName !== DYNAMIC_CACHE && \n                               cacheName !== IMAGE_CACHE;\n                    })\n                    .map(cacheName => {\n                        console.log('Deleting old cache:', cacheName);\n                        return caches.delete(cacheName);\n                    });\n                \n                return Promise.all(deletePromises);\n            })\n            .then(() => {\n                console.log('Service Worker activated');\n                return self.clients.claim();\n            })\n    );\n});\n\n// Fetch event - handle requests with caching strategies\nself.addEventListener('fetch', event => {\n    const request = event.request;\n    const url = new URL(request.url);\n    \n    // Skip non-GET requests\n    if (request.method !== 'GET') {\n        return;\n    }\n    \n    // Skip chrome-extension and other protocols\n    if (!url.protocol.startsWith('http')) {\n        return;\n    }\n    \n    // Find matching route strategy\n    const route = findRouteStrategy(request.url);\n    \n    if (route) {\n        event.respondWith(handleRequest(request, route));\n    } else {\n        // Default to network first for unmatched routes\n        event.respondWith(\n            handleRequest(request, {\n                strategy: CACHE_STRATEGIES.NETWORK_FIRST,\n                cache: DYNAMIC_CACHE\n            })\n        );\n    }\n});\n\n/**\n * Find the appropriate caching strategy for a URL\n */\nfunction findRouteStrategy(url) {\n    for (const route of ROUTE_STRATEGIES) {\n        if (route.pattern.test(url)) {\n            return route;\n        }\n    }\n    return null;\n}\n\n/**\n * Handle request based on caching strategy\n */\nasync function handleRequest(request, route) {\n    const { strategy, cache: cacheName, expiration } = route;\n    \n    try {\n        switch (strategy) {\n            case CACHE_STRATEGIES.CACHE_FIRST:\n                return await cacheFirst(request, cacheName, expiration);\n            \n            case CACHE_STRATEGIES.NETWORK_FIRST:\n                return await networkFirst(request, cacheName, expiration);\n            \n            case CACHE_STRATEGIES.STALE_WHILE_REVALIDATE:\n                return await staleWhileRevalidate(request, cacheName, expiration);\n            \n            case CACHE_STRATEGIES.NETWORK_ONLY:\n                return await fetch(request);\n            \n            case CACHE_STRATEGIES.CACHE_ONLY:\n                return await cacheOnly(request, cacheName);\n            \n            default:\n                return await networkFirst(request, cacheName, expiration);\n        }\n    } catch (error) {\n        console.error('Request handling failed:', error);\n        return await handleOffline(request);\n    }\n}\n\n/**\n * Cache First strategy\n */\nasync function cacheFirst(request, cacheName, expiration) {\n    const cache = await caches.open(cacheName);\n    const cachedResponse = await cache.match(request);\n    \n    if (cachedResponse) {\n        // Check if cache is expired\n        if (expiration && isCacheExpired(cachedResponse, expiration)) {\n            // Try to update cache in background\n            updateCacheInBackground(request, cacheName);\n        }\n        return cachedResponse;\n    }\n    \n    // Not in cache, fetch from network\n    const networkResponse = await fetch(request);\n    \n    if (networkResponse.ok) {\n        const responseClone = networkResponse.clone();\n        await cache.put(request, responseClone);\n    }\n    \n    return networkResponse;\n}\n\n/**\n * Network First strategy\n */\nasync function networkFirst(request, cacheName, expiration) {\n    try {\n        const networkResponse = await fetch(request);\n        \n        if (networkResponse.ok) {\n            const cache = await caches.open(cacheName);\n            const responseClone = networkResponse.clone();\n            await cache.put(request, responseClone);\n        }\n        \n        return networkResponse;\n    } catch (error) {\n        // Network failed, try cache\n        const cache = await caches.open(cacheName);\n        const cachedResponse = await cache.match(request);\n        \n        if (cachedResponse) {\n            return cachedResponse;\n        }\n        \n        throw error;\n    }\n}\n\n/**\n * Stale While Revalidate strategy\n */\nasync function staleWhileRevalidate(request, cacheName, expiration) {\n    const cache = await caches.open(cacheName);\n    const cachedResponse = await cache.match(request);\n    \n    // Start network request immediately\n    const networkPromise = fetch(request)\n        .then(networkResponse => {\n            if (networkResponse.ok) {\n                const responseClone = networkResponse.clone();\n                cache.put(request, responseClone);\n            }\n            return networkResponse;\n        })\n        .catch(error => {\n            console.warn('Network request failed:', error);\n            return null;\n        });\n    \n    // Return cached response immediately if available\n    if (cachedResponse) {\n        return cachedResponse;\n    }\n    \n    // If no cache, wait for network\n    return await networkPromise;\n}\n\n/**\n * Cache Only strategy\n */\nasync function cacheOnly(request, cacheName) {\n    const cache = await caches.open(cacheName);\n    const cachedResponse = await cache.match(request);\n    \n    if (cachedResponse) {\n        return cachedResponse;\n    }\n    \n    throw new Error('Resource not found in cache');\n}\n\n/**\n * Check if cached response is expired\n */\nfunction isCacheExpired(response, expiration) {\n    if (!expiration) return false;\n    \n    const cachedDate = response.headers.get('date');\n    if (!cachedDate) return false;\n    \n    const cacheTime = new Date(cachedDate).getTime();\n    const now = Date.now();\n    \n    return (now - cacheTime) > expiration;\n}\n\n/**\n * Update cache in background\n */\nasync function updateCacheInBackground(request, cacheName) {\n    try {\n        const networkResponse = await fetch(request);\n        \n        if (networkResponse.ok) {\n            const cache = await caches.open(cacheName);\n            await cache.put(request, networkResponse.clone());\n        }\n    } catch (error) {\n        console.warn('Background cache update failed:', error);\n    }\n}\n\n/**\n * Handle offline scenarios\n */\nasync function handleOffline(request) {\n    const url = new URL(request.url);\n    \n    // For HTML pages, return offline page\n    if (request.headers.get('accept').includes('text/html')) {\n        const cache = await caches.open(STATIC_CACHE);\n        return await cache.match('/offline.html');\n    }\n    \n    // For images, return placeholder\n    if (request.url.match(/\\.(png|jpg|jpeg|gif|webp|svg)$/)) {\n        const cache = await caches.open(IMAGE_CACHE);\n        return await cache.match('/assets/images/offline-placeholder.png');\n    }\n    \n    // For other resources, return a generic response\n    return new Response('Offline', {\n        status: 503,\n        statusText: 'Service Unavailable',\n        headers: {\n            'Content-Type': 'text/plain'\n        }\n    });\n}\n\n// Background sync for failed requests\nself.addEventListener('sync', event => {\n    if (event.tag === 'background-sync') {\n        event.waitUntil(handleBackgroundSync());\n    }\n});\n\n/**\n * Handle background sync\n */\nasync function handleBackgroundSync() {\n    // Retry failed analytics requests\n    const failedRequests = await getFailedRequests();\n    \n    for (const request of failedRequests) {\n        try {\n            await fetch(request);\n            await removeFailedRequest(request);\n        } catch (error) {\n            console.warn('Background sync failed for request:', request.url);\n        }\n    }\n}\n\n/**\n * Get failed requests from IndexedDB\n */\nasync function getFailedRequests() {\n    // Implementation would use IndexedDB to store failed requests\n    return [];\n}\n\n/**\n * Remove failed request from storage\n */\nasync function removeFailedRequest(request) {\n    // Implementation would remove from IndexedDB\n}\n\n// Push notifications\nself.addEventListener('push', event => {\n    if (!event.data) return;\n    \n    const data = event.data.json();\n    \n    const options = {\n        body: data.body,\n        icon: '/assets/images/icon.png',\n        badge: '/assets/images/badge.png',\n        data: data.data,\n        actions: data.actions || []\n    };\n    \n    event.waitUntil(\n        self.registration.showNotification(data.title, options)\n    );\n});\n\n// Notification click handling\nself.addEventListener('notificationclick', event => {\n    event.notification.close();\n    \n    if (event.action) {\n        // Handle specific action\n        handleNotificationAction(event.action, event.notification.data);\n    } else {\n        // Default action - open app\n        event.waitUntil(\n            clients.openWindow(event.notification.data.url || '/')\n        );\n    }\n});\n\n/**\n * Handle notification actions\n */\nfunction handleNotificationAction(action, data) {\n    switch (action) {\n        case 'view-product':\n            clients.openWindow(data.productUrl);\n            break;\n        case 'view-cart':\n            clients.openWindow('/cart.php');\n            break;\n        case 'dismiss':\n            // Do nothing, notification is already closed\n            break;\n    }\n}\n\n// Periodic background sync for cache cleanup\nself.addEventListener('periodicsync', event => {\n    if (event.tag === 'cache-cleanup') {\n        event.waitUntil(cleanupOldCaches());\n    }\n});\n\n/**\n * Cleanup old cache entries\n */\nasync function cleanupOldCaches() {\n    const cacheNames = [IMAGE_CACHE, DYNAMIC_CACHE];\n    \n    for (const cacheName of cacheNames) {\n        const cache = await caches.open(cacheName);\n        const requests = await cache.keys();\n        \n        for (const request of requests) {\n            const response = await cache.match(request);\n            \n            if (response) {\n                const cachedDate = response.headers.get('date');\n                if (cachedDate) {\n                    const age = Date.now() - new Date(cachedDate).getTime();\n                    const maxAge = cacheName === IMAGE_CACHE ? 30 * 24 * 60 * 60 * 1000 : 24 * 60 * 60 * 1000;\n                    \n                    if (age > maxAge) {\n                        await cache.delete(request);\n                    }\n                }\n            }\n        }\n    }\n}\n\n/**\n * Enhanced Notification Support Functions\n */\nfunction getUrlForNotificationAction(action, data) {\n    const actionUrls = {\n        create: '/customize-shirt.php',\n        browse: '/particulares.php',\n        checkout: '/checkout.php',\n        view_cart: '/checkout.php',\n        track: '/track-order.php?id=' + (data.orderId || ''),\n        view_product: '/product-detail.php?id=' + (data.productId || ''),\n        customize: '/customize-shirt.php',\n        shop_now: '/particulares.php',\n        view_offer: '/offers.php',\n        buy_now: '/particulares.php',\n        get_inspired: '/inspiration.php',\n        start_designing: '/customize-shirt.php'\n    };\n    \n    return actionUrls[action] || '/';\n}\n\nasync function sendNotificationAnalytics(event, data) {\n    try {\n        await fetch('/api/analytics/notification', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                event: event,\n                data: data,\n                timestamp: Date.now(),\n                userAgent: navigator.userAgent\n            })\n        });\n    } catch (error) {\n        console.error('Failed to send notification analytics:', error);\n    }\n}\n\n// Message handling for communication with main thread\nself.addEventListener('message', event => {\n    console.log('Service Worker received message:', event.data);\n    \n    if (event.data.type === 'SKIP_WAITING') {\n        self.skipWaiting();\n    } else if (event.data.type === 'GET_VERSION') {\n        event.ports[0].postMessage({ version: CACHE_NAME });\n    } else if (event.data.type === 'CLEAR_CACHE') {\n        clearAllCaches().then(() => {\n            event.ports[0].postMessage({ success: true });\n        });\n    }\n});\n\nasync function clearAllCaches() {\n    const cacheNames = await caches.keys();\n    return Promise.all(\n        cacheNames.map(cacheName => caches.delete(cacheName))\n    );\n}\n\nconsole.log('FractalMerch Service Worker v1.2.0 loaded successfully');